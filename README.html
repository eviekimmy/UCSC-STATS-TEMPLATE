<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.30">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="README_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting-de070a7b0ab54f8780927367ac907214.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="how-to-use-template" class="level1">
<h1>How to Use Template</h1>
<p>This is a template that allows you to render a quarto document into the template format for the FYE, which currently uses <code>icml2023</code>. This guide will give you some example code for installing and using the template.</p>
</section>
<section id="setup" class="level1">
<h1>Setup</h1>
<p>First, to download the template, type the following into your terminal:</p>
<blockquote class="blockquote">
<p>quarto use template eviekimmy/UCSC-STATS-TEMPLATE</p>
</blockquote>
<p>This will give you some prompts for installing:</p>
<blockquote class="blockquote">
<p>? Do you trust the authors of this template (Y/n) ‚Ä∫ Yes <br> ? Create a subdirectory for template? (Y/n) ‚Ä∫ No <br> [‚úì] Downloading <br> [‚úì] Unzipping <br></p>
<p>The template requires the following changes to extensions: <br> UCSC Statistics Template [Install] (format) <br> ? Would you like to continue (Y/n) ‚Ä∫ Yes <br></p>
</blockquote>
<p>Once this is done, add the following to the YAML of your .qmd document:</p>
<pre><code>---
title: 'YOUR TITLE'
author: 'YOUR NAME'
documentclass: article
classoption: twocolumn
format: 
  pdf: 
    theme: ucsc-stats-template
    keep-tex: true
---</code></pre>
<p>The <code>keep-tex</code> command is optional. This allows you the original <code>.tex</code> file that is generated before rendering to pdf. This is useful for catching any latex issues, as well as for making slight adjustments to the format before rendering and turning in. (NOTE: If you are making edits to the <code>.tex</code> file, make sure to not render <code>.qmd</code>, as this will override any changes you made. Or, you can rename the <code>.tex</code> file you are editing and turn the renamed file in).</p>
</section>
<section id="formatting" class="level1">
<h1>Formatting</h1>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>Include the following into the YAML:</p>
<pre><code>abstract: |
  the content of your abstract here</code></pre>
<p>The <code>|</code> allows for extra text for anything indented underneath.</p>
</section>
<section id="code-chunk-options" class="level2">
<h2 class="anchored" data-anchor-id="code-chunk-options">Code Chunk Options</h2>
<p>For quarto, the preferred way is to use the <code>#|</code> format</p>
<pre><code>#| echo: false
#| eval: true</code></pre>
<p>These go at the start of your code block. I would always include <code>echo</code> and <code>eval</code> as options in your r chunk. <code>echo</code> tells quarto whether you want the code to be pasted into the document text or not, and <code>eval</code> tells you whether quarto should run the code. Most often, <code>echo: false</code>. The state for <code>eval</code> is useful if you decide that you no longer want a table or figure to be include in your report, but still want the flexibility of pasting it back in later. I also typically run a simulation in its own code chunk and save it to csv, which I will read in later. This allows me to set <code>eval: false</code> on the simulation code and have my document render faster when I make slight adjustments.</p>
<p>Some other options are <code>warning</code> and <code>message</code>, and <code>error</code>, for controlling warning outputs, message outputs, and whether to run code with errors.</p>
</section>
<section id="figures" class="level2">
<h2 class="anchored" data-anchor-id="figures">Figures</h2>
<p>There are two types of figures that you can use: figures that take up one column, and figures that take up the entire page width. For column-wide figures, include the following options at the start of your code chunk:</p>
<pre><code>#| echo: false 
#| message: false
#| warning: false
#| label: fig-label
#| fig-asp: 0.4 
#| fig-pos: 'htbp'
#| fig-cap: 'CAPTION HERE'</code></pre>
<p>Ensure that the label starts with <code>fig-</code>. These can be referenced in your quarto document by typing <code>@fig-label</code>. The <code>fig-asp</code> option is the <code>height/width</code> ratio of the figure. 0.4 seems to be a good ratio for most plots, and plots that are faceted (i.e.&nbsp;include <code>facet_wrap</code>) are usually appealing when <code>fig-asp</code> is 0.6.</p>
<p>Page-width figures are usually for when you want multiple subfigures. Include the following options at the start of your code chunk:</p>
<pre><code>#| echo: false 
#| message: false 
#| label: fig-label
#| layout-ncol: 2 
#| fig-env: figure* 
#| fig-asp: 0.4
#| fig-pos: 'htbp' 
#| fig-cap: 'MAIN FIGURE CAPTION HERE' 
#| fig-subcap: 
#| - 'CAPTION FOR SUBFIGURE 1' 
#| - 'CAPTION FOR SUBFIGURE 2' 
#| - 'ETC' </code></pre>
<p>The option <code>layout-ncol</code> specifies how many columns it wants to have for the figures. So, for example, if you want to include three subfigures, setting <code>layout-ncol: 2</code> will paste two of the subfigures next to each other and the other on the bottom left. The figures will be pasted by row. For this example, this means the first figure in your chunk will be pasted in the top-left position, the second figure in the top-right, and the third in the bottom left. The options <code>fig-cap</code> and <code>fig-subcap</code> are self-explanatory. When referencing the subfigures, add a dash and the numbered figure you want after the label. So, if you want to reference the first subfigure generated in the figure, type <code>@fig-label-1</code>.</p>
</section>
</section>
<section id="tables" class="level1">
<h1>Tables</h1>
<p>Quarto allows for multiple ways to include a table. For now, I will focus on tables generated from r code. If you would like to learn more about generating tables in line, <a href="https://quarto.org/docs/authoring/tables.html">click here</a>. First, ensure that you have the <code>kableExtra</code> package loaded in your document. This can be done using the following:</p>
<pre><code>install.packages('kableExtra')
library(kableExtra)</code></pre>
<p>Next, add the following options to the top of your code chunk:</p>
<pre><code>#| echo: false
#| message: false
#| warning: false
#| label: tbl-label
#| tbl-cap: 'CAPTION HERE'</code></pre>
<p>Ensure that the label starts with <code>tbl-</code>. These can be referenced in your quarto document by typing <code>@tbl-label</code>. After you have the <code>table</code> you want to generate, pipe the following:</p>
<pre><code>table %&gt;% kbl(booktabs=T) # need tidyverse loaded to use
table |&gt; kbl(booktabs=T)  # base R pip operator that is slightly more limited</code></pre>
<p>Currently there is no support for <code>longtables</code>. For now, tables only take up the column width of the document. Also, make sure that the text within the table is not too wide, as this will run into the other column and interfere with the other text.</p>
</section>
<section id="citations-and-bibliography" class="level1">
<h1>Citations and Bibliography</h1>
<p>First, ensure the citations are saved to a <code>.bib</code> file. Then, add the following in the YAML:</p>
<pre><code>bibliography: YOURCITATIONS.bib</code></pre>
<p>These can be referenced with <code>@citation</code>, where citation is the label you gave the citation in your <code>.bib</code> file. For example, If using <code>example-citations.bib</code>, I would type <code>@douglass_jacksfilms_2021</code> if I wanted to reference <a href="https://www.tiktok.com/@jackstiks/video/6985246283925572870">Jacksfilm‚Äôs meltdown over the Pizza Planet Truck</a>:</p>
<blockquote class="blockquote">
<p>‚ÄúiT sHoUlD oNlY bE iN tOy sToRy üò≠‚Äù <span class="citation" data-cites="douglass_jacksfilms_2021">@douglass_jacksfilms_2021</span></p>
</blockquote>
</section>
<section id="referencing-inline-code" class="level1">
<h1>Referencing Inline Code</h1>
<p>Adding `{r} CODE HERE ` allows you to run inline code in your document. So, for example, you can define a variable that contains a posterior credible interval like so:</p>
<pre><code># takes 95% symmetric credible interval and rounds to three digits
interval = posterior %&gt;% quantile(c(0.025, 0.075)) %&gt;% round(3)</code></pre>
<p>and reference it in you text like this:</p>
<blockquote class="blockquote">
<p>The credible interval for the distribution is [`{r} interval`].</p>
</blockquote>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>